#!/usr/bin/perl
# Match list support for AMMS (C) 2009

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
	    
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
			    
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

package AMMS::Match;

use FCGI;
use FCGI::ProcManager qw(pm_manage pm_pre_dispatch pm_post_dispatch);

use DBI;
use Config::General;
use Socket qw(inet_ntoa);
use Net::IP::CMatch qw(match_ip);
use URI::Split qw(uri_split);
use Params::Validate qw(:all);
use Getopt::Long;
use POSIX;
use Sys::Syslog qw(:standard :macros);

my $VERSION = "0.1";
my $DEBUG = 0;

my $config_file;
my $profile;
my %config;
my $foreground;
my %db;

my $pid_file = "/var/run/matchd.pid";

GetOptions ("config|c=s" => \$config_file, "profile|p=s" => \$profile, "foreground|f" => \$foreground);

sub load_config {

    $config_file ||= "/etc/amms.conf";
    $profile ||= "default";
    %config = Config::General::ParseConfig (-ConfigFile => $config_file, -InterPolateVars => 1);
    openlog ('matchd', $config {$profile}{matchd}{log}{options} || 'ndelay,pid', $config {$profile}{matchd}{log}{facility} || 'daemon');
}

my $op = $ARGV [0] || "";

if ($op =~ /^start$/i){
    load_config ();
    run ($foreground);
}
elsif ($op =~ /^stop$/i){
    if (stop ()){ # kill running instance
    	print "OK\n";
    }
    exit;
}
elsif ($op =~ /^restart$/i){
    print "Restarting...\n";
    stop ();
    sleep (1);
    load_config ();
    run ($foreground);
}
elsif ($op =~ /^status$/i){
    status ();
    exit;
}
elsif ($op =~ /^version$/i){
    print "$VERSION\n";
    exit;
}
else {
    print "matchd $VERSION\n";
    print "Usage: matchd [--config|-c file] [--foreground|-f] [--profile|-p] start|stop|restart|version\n";
    exit;
}

sub status {

    my $pid;

    if (open (FH, "<$pid_file")){
        $pid = <FH>;
	    close FH;
    }
    
    if ($pid){
        if (kill (0, $pid)){
	        print "Running with pid $pid\n";
	        return;
	    }
        else {
	        print "Abnormal previous termination\n";
        }
    }
    print "Not running\n";
}

sub run {

    my $fg = shift;
    my $pid;
    
    if (open (FH, "<$pid_file")){
        $pid = <FH>;
	    close FH;
    }
    
    if ($pid){
        if (kill (0, $pid)){
	        error ("Already running with pid $pid", 1);
	    }
        else {
	        error ("Abnormal previous termination");
	        unlink $pid_file or error ("Can't unlink pid file: $!", 1);
	        error ("Old pid file removed");
        }
    }
    
    return if $fg; # foreground mode
    
    # background mode
    
    $| = 1;
    print "Running in background mode\n";
    
    chdir '/' or error ("Can't chdir to /: $!", 1);
    umask 0;
    
    open STDIN, '/dev/null'   or error ("Can't read /dev/null: $!", 1);
    open STDOUT, '>/dev/null' or error ("Can't write to /dev/null: $!", 1);
    open STDERR, '>/dev/null' or error ("Can't write to /dev/null: $!", 1);

    defined ($pid = fork)  or error ("Can't fork: $!");
    exit if $pid;
    setsid or error ("Can't start a new session: $!", 1);
    
    open (FH, ">$pid_file") or error ("Can't write pid file: $!", 1);
    print FH $$;
    close FH;

    chmod 0644, $pid_file;

    syslog ('notice', "Run OK");
    syslog ('notice', sprintf ("listen on %s instances %s qlen %s", $config{$profile}{matchd}{socket},
                                $config{$profile}{matchd}{instances},
                                $config{$profile}{matchd}{queue}));
}

sub stop {
    
    my $pid;
    
    if (open (FH, "<$pid_file")){
        $pid = <FH>;
	    close FH;
    }        
    if ($pid){
	    unlink $pid_file;
	    return kill ("TERM", $pid);
    }
}

sub error {
    
    my ($msg, $die) = @_;
    
    $| = 1;
    
    syslog (LOG_ERR, $msg);
    $die ? die $msg : print "$msg\n";
}

my $socket  = FCGI::OpenSocket ($config{$profile}{matchd}{socket}, $config{$profile}{matchd}{queue});
my $request = FCGI::Request (\*STDIN, \*STDOUT, \*STDERR, \%ENV, $socket, FCGI::FAIL_ACCEPT_ON_INTR);

pm_manage (n_processes => $config{$profile}{matchd}{instances});

$0 = "matchd";

my $user = $config {$profile}{matchd}{user};

if ($user){

    use User::pwent;
    my $pw = getpwnam ($user) || error ("Unknown user $user", 1);

	if (POSIX::setgid ($pw->gid)){
        syslog ('notice', "group id " . $pw->gid);
	}
    if (POSIX::setuid ($pw->uid)){
        syslog ('notice', "user $user id " . $pw->uid);
    }
}

while ($request->Accept() >= 0) {

    pm_pre_dispatch ();

    my ($req, $cmd, @arg, @res, $res);

    $req = $ENV {QUERY_STRING};
    $req =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
    $req = substr ($req, 2);

    ($cmd,@arg) = split (/\s/, $req);

    print "Content-Type: text/plain\n\n";

    unless ($cmd){
        pm_post_dispatch ();
        next;
    }

    debug ("> $req\n");

    @res = eval __PACKAGE__ . "::$cmd" . '(@arg)';

    if (@res){
        if (ref ($res [0]) eq "ARRAY"){
            foreach (@res){
                $res = join (' ', @{$_});
                $res.= "\n";
                print $res;
                debug ("< $res");
            }
        }
        else {
            $res = join (' ', @res);
            $res.= "\n";
            print $res;
            debug ("< $res");
        }
    }
    else{
        print "ERR $@\n";
    }

    pm_post_dispatch ();
}

FCGI::CloseSocket($socket);

sub debug {
    return unless $DEBUG;
    print  STDERR $_[0];
}

sub get_dbh {

    my $name = shift;
    my $dbh = $db{$name}{handle};

    if ($dbh){
        unless ($dbh->ping){
            $dbh->disconnect;
            undef $dbh;
        }
    }
    $dbh ||= DBI->connect ($config {$name}{db}{dsn}, $config {$name}{db}{user}, $config{$name}{db}{pass},
                          {RaiseError => 1, PrintError => 1, AutoCommit => 1});

    if ($dbh){
        $db {$name}{handle} = $dbh;
    }
    return $dbh;
}

sub add {

    validate_pos (@_, 1, 1, 1);

    my ($db_name, $table, $adr) = @_;
    my $dbh = get_dbh ($db_name);

    $dbh->do ("INSERT INTO `$table` (address) VALUES (?)", undef, $adr);
}

sub rem {

    validate_pos (@_, 1, 1, 1);

    my ($db_name, $table, $adr) = @_;
    my $dbh = get_dbh ($db_name);

    $dbh->do ("DELETE FROM `$table` where address=?", undef, $adr);
}

sub ls {

    validate_pos (@_, 1, 1, 1);

    my ($db_name, $table, $adr) = @_;
    my $dbh = get_dbh ($db_name);

    my $row = $dbh->selectcol_arrayref (qq{ SELECT address FROM `$table` WHERE address REGEXP ? }, undef, $adr);
    return @$row;
}

sub check {
    
    validate_pos (@_, 1, 1, 1);

    my ($db_name, $table, $adr) = @_;
    my $dbh = get_dbh ($db_name);

    my ($scheme, $domain, $path, $query, $frag) = uri_split ($adr);

    $domain = lc $domain;
    $adr = lc "$domain$path";

    if ($config {$profile}{matchd}{$table}{check_domain_only}){
        $adr = $domain;
    }

    my @row = $dbh->selectrow_array ("SELECT * FROM `$table` WHERE address=? LIMIT 1", undef, $adr);

    return "OK" if (@row);

    if ($config {$profile}{matchd}{$table}{check_domain_only} && $adr){

        my $packed_ip = gethostbyname ($adr);
        my $ip_address;

        if (defined $packed_ip) {
           $ip_address = inet_ntoa ($packed_ip);
        }
        my $ranges = $dbh->selectcol_arrayref ("SELECT address FROM `$table` WHERE address REGEXP '[[:digit:]]'");
        return "OK" if (match_ip ($ip_address, @$ranges));
    }

    return "ERR not found";
}

