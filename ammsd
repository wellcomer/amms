#!/usr/bin/perl
# AMMS FCGI (C) 2009

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# any later version.
        
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
                
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;

package AMMSD;

use FCGI;
use FCGI::ProcManager qw(pm_manage pm_pre_dispatch pm_post_dispatch);

use DBI;
use Sys::Syslog qw(:standard :macros);
use Config::General;
use Getopt::Long;
use Params::Validate qw(:all);
use POSIX;
use Carp;

use lib '/usr/lib/amms/';

my $VERSION = 0.1;
my $DEBUG = 0;

my %config;
my %db;
my $db;

my $config_file;
my $foreground;
my $pid_file = "/var/run/ammsd.pid";

my $validate_type_regex = qr/(T|I|P)/;
my $validate_value_regex = qr/\d+\.*\d*(b|k|m|g|$)/i;
my $validate_period_regex = qr/\d+(s|m|h|d)/i;

sub validation_err {
    croak shift;
}

sub load_config {
    
    $config_file ||= '/etc/amms.conf';

    %config = ();    
    %config = Config::General::ParseConfig (-ConfigFile => $config_file, -InterPolateVars => 1);
    
    my $keys_count = scalar keys (%config);
    
    openlog ('ammsd', $config {ammsd}{log}{options} || 'ndelay,pid', $config {ammsd}{log}{facility} || 'daemon');
    syslog ('notice', "Configuration file $config_file has $keys_count keys");
    
    unless ($keys_count){
        error ("Bad configuration in $config_file", 1);
    }

    return $keys_count;
}

validation_options (on_fail => \&AMMSD::validation_err);

GetOptions ("config|c=s" => \$config_file, "foreground|f" => \$foreground);

my $op = $ARGV [0] || "";

if ($op =~ /^start$/i){

    load_config ();
    run ($foreground);
}
elsif ($op =~ /^stop$/i){
    if (stop ()){ # kill running instance
        print "OK\n";
    }
    exit;
}
elsif ($op =~ /^restart$/i){
    print "Restarting...\n";
    stop ();
    sleep (1);
    load_config ();
    run ($foreground);
}
elsif ($op =~ /^status$/i){
    status ();
    exit;
}
elsif ($op =~ /^version$/i){
    print "$VERSION\n";
    exit;
}
else {
    print "ammsd $VERSION\n";
    print "Usage: ammsd [--config|-c file] [--foreground|-f] start|stop|restart|version\n";
    exit;
}

sub status {

    my $pid;

    if (open (FH, "<$pid_file")){
        $pid = <FH>;
        close FH;
    }
    
    if ($pid){
        if (kill (0, $pid)){
            print "Running with pid $pid\n";
            return;
        }
        else {
            print "Abnormal previous termination\n";
        }
    }
    print "Not running\n";
}

sub run {

    my $fg = shift;
    my $pid;
    
    if (open (FH, "<$pid_file")){
        $pid = <FH>;
        close FH;
    }
    
    if ($pid){
        if (kill (0, $pid)){
            error ("Already running with pid $pid", 1);
        }
        else {
            error ("Abnormal previous termination");
            unlink $pid_file or error ("Can't unlink pid file: $!", 1);
            error ("Old pid file removed");
        }
    }
    
    return if $fg; # foreground mode
    
    # background mode
    
    $| = 1;
    print "Running in background mode\n";
    
    chdir '/' or error ("Can't chdir to /: $!", 1);
    umask 0;
    
    open STDIN, '/dev/null'   or error ("Can't read /dev/null: $!", 1);
    open STDOUT, '>/dev/null' or error ("Can't write to /dev/null: $!", 1);
    open STDERR, '>/dev/null' or error ("Can't write to /dev/null: $!", 1);

    defined ($pid = fork)  or error ("Can't fork: $!");
    exit if $pid;
    setsid or error ("Can't start a new session: $!", 1);
    
    open (FH, ">$pid_file") or error ("Can't write pid file: $!", 1);
    print FH $$;
    close FH;

    chmod 0644, $pid_file;

    syslog ('notice', "Run OK");
    syslog ('notice', sprintf ("listen on %s instances %s qlen %s", $config{ammsd}{socket}, $config{ammsd}{instances},$config{ammsd}{queue}));
}

sub stop {
    
    my $pid;
    
    if (open (FH, "<$pid_file")){
        $pid = <FH>;
        close FH;
    }        
    if ($pid){
        unlink $pid_file;
        return kill ("TERM", $pid);
    }
}

sub error {
    
    my ($msg, $die) = @_;
    
    $| = 1;
    
    syslog (LOG_ERR, $msg);
    $die ? croak $msg : carp "$msg\n";
}

my $socket  = FCGI::OpenSocket ($config{ammsd}{socket}, $config{ammsd}{queue});
my $request = FCGI::Request (\*STDIN, \*STDOUT, \*STDERR, \%ENV, $socket, FCGI::FAIL_ACCEPT_ON_INTR);

pm_manage (n_processes => $config{ammsd}{instances});

$0 = "ammsd";

my $user = $config {ammsd}{user};

if ($user){

    use User::pwent;
    my $pw = getpwnam ($user) || error ("Unknown user $user", 1);

    if (POSIX::setgid ($pw->gid)){
        syslog ('notice', "group id " . $pw->gid);
    }
    if (POSIX::setuid ($pw->uid)){
        syslog ('notice', "user $user id " . $pw->uid);
    }
}

while ($request->Accept() >= 0) {

    pm_pre_dispatch ();

    my ($req, $cmd, @arg, @res, $res);
    
    $req = $ENV {QUERY_STRING};
    $req =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
    $req = substr ($req, 2);

    ($cmd,@arg) = split (/\s/, $req);

    print "Content-Type: text/plain\n\n";

    unless ($cmd){
        pm_post_dispatch ();
        next;
    }

    debug ("> $_\n");

    @res = eval __PACKAGE__ . "::$cmd" . '(@arg)';

    if (@res){
        if (ref ($res [0]) eq "ARRAY"){
            foreach (@res){
                $res = join (' ', @{$_});
                $res.= "\n";
                print $res;
                debug ("< $res");
            }
        }
        else {
            $res = join (' ', @res);
            $res.= "\n";
            print $res;
            debug ("< $res");
        }
    }
    else{
        print "ERR $@\n";
    }

    pm_post_dispatch ();
}

FCGI::CloseSocket($socket);

sub debug {
    return unless $DEBUG;
    print  STDERR $_[0];
}

sub get_config_loc {
    return $config_file;
}

sub byte {

    validate_pos (@_, 1);

    my ($value) = @_;

    $value = lc ($value);
    $value =~ /(\d+\.*\d*)([b|k|m|g]*)/;

    my $dig  = $1 || 0;
    my $unit = $2 || 'b'; # default unit is byte

    my %mul = (b => 1, k => 1024, m => 1048576, g => 1073741824);
    my $byte = int $dig * $mul {$unit};
}

sub delta_time {

    validate_pos (@_, 1);

    my ($value) = @_;
   
    $value = lc ($value);
    $value =~ /(\d+)([s|m|h|d]*)/;

    my $dig  = $1 || 0;
    my $unit = $2 || 'd'; # default unit is day

    my %mul = (s => 1, m => 60, h => 3600, d => 86400);
    my $delta_time = $dig * $mul {$unit};
}

sub get_dbh {

    my $name = shift;
    my $dbh = $db{$name}{handle};

    if ($dbh){
        unless ($dbh->ping){
            $dbh->disconnect;
            undef $dbh;
        }
    }
    $dbh ||= DBI->connect ($config {$name}{db}{dsn}, $config {$name}{db}{user}, $config{$name}{db}{pass},
                          {RaiseError => 1, PrintError => 1, AutoCommit => 1});

    if ($dbh){
        $db {$name}{handle} = $dbh;
    }
    return $dbh;
}

sub get_limit {

    validate_pos (@_, 1, {regex => $validate_type_regex}, 1);
    my ($db_name, $type, $ident) = @_;

    my $dbh = get_dbh ($db_name);
    my @val = $dbh->selectrow_array ("select `parent`,`value`,`period`,`stat`,unix_timestamp(ts),`desc` from lim where type=? and ident=?",
                                      undef, $type, $ident);
    return @val;
}

sub get_anylimit {

    validate_pos (@_, 1, 1);
    my ($db_name, $ident) = @_;    

    my @val;    # value, period, stat, ts
    my $type;   # limit type
    my $group;  # user group

    $type = 'T';        # temp limit
    @val = get_limit ($db_name, $type, $ident);

    unless (@val) {
        $type = 'I';    # ident limit
        @val = get_limit ($db_name, $type, $ident);
    }

    unless (@val) {
        $type = 'P';    # parent limit
        @val = get_limit ($db_name, $type, $ident);
    }

    my $par = $val [0] || 'default';
    my @par_val = get_limit ($db_name, 'P', $par);
  
    if (@par_val){
        my $i;
        for ($i=1; $i <= $#par_val; $i++){
            $val [$i] = $par_val [$i] unless (defined $val [$i]);
        }
    }
    
    if (@val){
        unshift @val, $ident;
        unshift @val, $type;
    }
    return  @val;
}

sub add_limit {

    validate_pos (@_, 1, {regex => $validate_type_regex}, 1, {regex => $validate_value_regex}, {regex => $validate_period_regex}, 0, 0);
    my ($db_name, $type, $ident, $value, $period, $stat, $desc) = @_;

    my $dbh = get_dbh ($db_name);

    # save description if exists

    my @val = get_limit ($db_name, $type, $ident);
    $desc ||= $val [$#val];

    $dbh->do ("delete from lim where type=? and ident=?", undef, $type, $ident);
    my $res = $dbh->do ("insert into lim(`type`,`ident`,`value`,`period`,`stat`,`desc`) values(?,?,?,?,?,?)",
                         undef, $type, $ident, $value, $period, $stat, $desc);

    update_limit_ts ($db_name, $type, $ident, $period);

    return $res;
}

sub add_limit_template {
 
    validate_pos (@_, 1, {regex => $validate_type_regex}, 1);
    my ($db_name, $type, $ident) = @_;

    my $dbh = get_dbh ($db_name);

    $dbh->do ("delete from lim where type=? and ident=?", undef, $type, $ident);
    return $dbh->do ("insert into lim(`type`,`ident`) values(?,?)", undef, $type, $ident);
}

sub remove_limit {

    validate_pos (@_, 1, {regex => $validate_type_regex}, 1);
    my ($db_name, $type, $ident) = @_;

    my $dbh = get_dbh ($db_name);

    if ($dbh->do ("delete from lim where ident=? and type=?", undef, $ident, $type)){
        return 1;
    }
    return undef;
}

sub update_limit {

    validate_pos (@_, 1, 1, 1, 1, 0);
    my ($db_name, $type, $ident, $field, $value) = @_;

    my $dbh = get_dbh ($db_name);

    if ($dbh->do ("update lim set `$field`=? where ident=? and type=?", undef, $value, $ident, $type)){
        return 1;
    }
    return undef;
}

sub update_limit_ts {
    
    validate_pos (@_, 1, 1, 1, 1);
    my ($db_name, $type, $ident, $period) = @_;

    my $dbh = get_dbh ($db_name);

    my ($sec,$min,$hour,$mday,$mon,$year) = localtime (time);
    $year += 1900; $mon += 1;

    if ($config {$db_name}{timer} eq "abs"){ # absolute timer

        if ($period =~ /m/){ # minutes
            $sec = 0;
        }
        elsif ($period =~ /h/){
            $min = $sec = 0;
        }
        elsif ($period =~ /d/){
            $hour = $min = $sec = 0;
        }
    }
    
    my $ts = sprintf ("%04d%02d%02d%02d%02d%02d", $year, $mon, $mday, $hour, $min, $sec);

    if ($dbh->do ("update lim set `ts`=? where ident=? and type=?", undef, $ts, $ident, $type)){
        return 1;
    }
    return undef;
}

sub list_limits {

    validate_pos (@_, 1);
    my ($db_name) = @_;
    
    my $dbh = get_dbh ($db_name);
    my $limits = $dbh->selectall_arrayref ("select * from lim");

    return @{$limits};
}

sub list_traf {

    validate_pos (@_, 1);
    my ($db_name) = @_;
    
    my $dbh = get_dbh ($db_name);
    my $traf = $dbh->selectall_arrayref ("select * from traf");

    return @{$traf};
}

sub add_traf {

    validate_pos (@_, 1, 1, 1, 0);
    my ($db_name, $ident, $delta_size, $delta_size_hit) = @_;

    $delta_size_hit ||= 0;

    my $dbh = get_dbh ($db_name);
    return $dbh->do ("insert into traf (size,size_hit,ident) values (?,?,?) on duplicate key update size=size+$delta_size,
                      size_hit=size_hit+$delta_size_hit", undef, $delta_size, $delta_size_hit, $ident);
}

sub get_traf {

    validate_pos (@_, 1, 1);
    my ($db_name, $ident) = @_;

    my $dbh = get_dbh ($db_name);
    return $dbh->selectrow_array ("select size,size_hit from traf where ident=?", undef, $ident);
}

sub reset_traf {

    validate_pos (@_, 1, 1);
    my ($db_name, $ident) = @_;

    my $dbh = get_dbh ($db_name);
    return $dbh->do ("update traf set size=0,size_hit=0 where ident=?", undef, $ident);
}

sub check_access {

    validate_pos (@_, 1, 1);

    my ($db_name, $ident) = @_;

    my ($type,$stub,$parent,$value,$period,$stat,$ts) = get_anylimit ($db_name, $ident);
    return "ERR not found" unless $type;
    return "ERR disabled by adm" if ($stat==2);

    my ($size,$size_hit) = get_traf ($db_name, $ident);

    my $now = time;
    my $delta_time = delta_time ($period);
    my $size_limit = byte ($value);

    $size += $size_hit if ($config {$db_name}{hit_count});

    if ($now >= ($ts + $delta_time)) { # expired limit
        if ($type eq 'T'){
            remove_limit ($db_name, $type, $ident);
            return "OK";
        }
        else {
            update_limit_ts ($db_name, $type, $ident, $period);
            update_limit ($db_name, $type, $ident, stat => 1) if ($stat == 0); # enable
            reset_traf ($db_name, $ident);
            event ($db_name, "check_access.enable", $type, $ident);
            return "OK";
        }
    }

    if ($size_limit==0){ # unlim
        return "OK";
    }

    if ($size > $size_limit and $now < ($ts + $delta_time)){
        if ($stat == 1){
            update_limit ($db_name, $type, $ident, stat => 0);
            event ($db_name, "check_access.disable", $type, $ident);
        }
        return "ERR disabled by sys";
    }

    if ($stat == 0){ # keep actual stat after reset_traf
        update_limit ($db_name, $type, $ident, stat => 1);
        event ($db_name, "check_access.enable", $type, $ident);
    }

    return "OK";
}

sub run_extension {

    validate_pos (@_, 1, 1, (0) x (@_ - 2));

    my ($profile_name, $ext_name, @arg) = @_;
    my ($ext, $res);

    $ext = $config {$profile_name}{extension}{$ext_name};

    my ($ext_type, $ext) = split (/\s/, $ext, 2);
    $ext_type = lc $ext_type;

    if ($ext_type eq "sh"){

        unless (open (EXT, "$ext @arg 2>&1 |")){
            return "ERR $!"
        }
        while (<EXT>){
            $res .= $_;
        }
        close (EXT);
    }
    elsif ($ext_type eq "ammsc") {

        my $arg0 = shift @arg;
        unshift @arg, $profile_name;
        unshift @arg, $arg0;

        use AMMS::Client;
        
        my $ammsc = AMMS::Client->new;
           $ammsc->connect ($ext) || return "ERR can't connect to $ext";
           $ammsc->c2c (1);
           return $ammsc->exe (@arg);
    }
    else {
        return "ERR extension type $ext_type unknown";
    }

    return $res;
}

sub ls_extension {

    validate_pos (@_, 1);
    my $profile_name = shift;

    return keys %{$config {$profile_name}{extension}};
}

sub event {

    my ($profile_name, $event_name, @argv) = @_;
    
    my $event_handler = $config {$profile_name}{event}{$event_name};
    my ($ext_name, @arg) = split (/\s/, $event_handler, 2);

    push @argv, @arg;

    run_extension ($profile_name, $ext_name, @argv);
}

